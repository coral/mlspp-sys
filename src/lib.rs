//! Raw FFI bindings to [Cisco mlspp](https://github.com/cisco/mlspp), a C++
//! implementation of the Messaging Layer Security (MLS) protocol
//! ([RFC 9420](https://www.rfc-editor.org/rfc/rfc9420.html)).
//!
//! This crate provides unsafe, low-level bindings generated by
//! [bindgen](https://docs.rs/bindgen) from a thin C wrapper around mlspp.
//! It is intended as a building block for safe Rust wrappers rather than for
//! direct use in application code.
//!
//! # Crate features
//!
//! | Feature | Default | Description |
//! |---------|---------|-------------|
//! | `vendored` | **yes** | Build mlspp from the vendored source tree via CMake |
//! | `system` | no | Link against a system-installed mlspp |
//! | `libdave-compat` | no | Enable compatibility with Discord's libdave MLS fork |
//!
//! # Safety
//!
//! All functions in this crate are `unsafe` and follow C ownership conventions:
//!
//! - **Pointer validity** — every pointer argument must be non-null and point to
//!   a live object of the correct type, unless the function documentation
//!   explicitly allows NULL.
//! - **Thread safety** — mlspp objects are *not* thread-safe. Do not share
//!   handles across threads without external synchronization.
//!
//! # Memory management
//!
//! The API uses two patterns:
//!
//! - **Opaque handles** — types like [`mlspp_state_t`], [`mlspp_session_t`],
//!   etc. are heap-allocated opaque pointers. Each has a corresponding `_free`
//!   function (e.g. [`mlspp_state_free`]) that must be called exactly once when
//!   the handle is no longer needed.
//! - **Byte buffers** — [`mlspp_bytes_t`] is a `{data, len}` pair returned by
//!   many accessors and serialization functions. Free these with
//!   [`mlspp_bytes_free`]. Do not call `free()` on the inner `data` pointer
//!   directly.
//!
//! # Error handling
//!
//! Functions that can fail return either a NULL pointer (for handle-returning
//! functions) or `{NULL, 0}` (for bytes-returning functions). In both cases
//! [`mlspp_last_error`] returns a thread-local error string describing the
//! failure. On success, [`mlspp_last_error`] returns NULL.
//!
//! # API levels
//!
//! The bindings expose two layers from the underlying C wrapper:
//!
//! - **Low-level (`State`)** — direct access to MLS group state, proposals,
//!   commits, and application data protection. Use this when you need full
//!   control over the MLS state machine.
//! - **High-level (`Client` / `Session`)** — a simplified API that manages key
//!   generation and state transitions internally. Use this for straightforward
//!   group messaging scenarios.
//!
//! # Build requirements
//!
//! When the `vendored` feature is enabled (default), building this crate
//! requires:
//!
//! - A C++17 compiler (GCC 8+, Clang 7+, MSVC 2019+)
//! - CMake 3.16+
//! - OpenSSL development headers (or set `OPENSSL_ROOT_DIR`)

#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
